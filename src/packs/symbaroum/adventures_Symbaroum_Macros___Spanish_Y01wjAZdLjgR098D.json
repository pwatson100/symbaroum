{
  "name": "Symbaroum Macros - Spanish",
  "img": "systems/symbaroum/asset/image/cover-system-adv.webp",
  "caption": "",
  "sort": 0,
  "description": "<p>This contains useful macros in Spanish</p>",
  "actors": [],
  "combats": [],
  "items": [],
  "journal": [],
  "scenes": [],
  "tables": [],
  "macros": [
    {
      "name": "Add Exp",
      "type": "script",
      "author": "YsmQXJ6sqv5HM9Ov",
      "img": "icons/svg/upgrade.svg",
      "scope": "global",
      "command": "/** \n * Macro can be used by either selecting tokens on-screen or, if no tokens are selected, choosing which player characters (default all)\n * \n */\n (()=>{\n    let defaultCheck = \"checked\"; // set to unchecked\n    let actorslist = [];\n\n    if(canvas.tokens.controlled.length > 0) {\n        // If no actor selected\n        // Time to get busy\n        canvas.tokens.controlled.map(e => { \n            if(e.actor.data.type === \"player\") {\n                if(game.user.isGM || e.actor.owner)\n                    actorslist.push(e.actor);\n            }\n        });\n    } else {     \n        let gameacts = game.actors.filter(e => { if( (game.user.isGM || e.owner) && e.data.type === \"player\") { return e; } });\n        Array.prototype.push.apply(actorslist, gameacts);\n    }\n\n    let allKeys = \"\";\n    actorslist.forEach(t => {\n        allKeys = allKeys.concat(`<div style=\"flex-basis: auto;flex-direction: row;display: flex;\">\n                <div style=\"width:10em;min-width:10em;\"><label for=\"${t.data._id}\">${t.data.name}</label> </div>\n                <div><input id=\"${t.data._id}\" type=\"checkbox\" name=\"selection\" value=\"${t.data._id}\" ${defaultCheck}=\"${defaultCheck}\"></div>\n            </div>`);\n    });\n\n    let dialog_content = `  \n    <div class=\"form-group\">\n    <h2>Select player(s)</h2>\n    ${allKeys}\n    <br />\n    <div style=\"flex-basis: auto;flex-direction: row;display: flex;\">\n                <div style=\"width:10em;min-width:10em;\"><label for=\"experience\" style=\"width:10em;min-width:10em\">Experience</label></div><div><input type=\"text\" name=\"experience\" value=\"1\" style=\"width:5em\"></div>\n    </div>\n    <br/>\n    </div>`;\n    let x = new Dialog({\n        title: \"Add experience\",\n        content : dialog_content,\n        buttons : \n        {\n            Ok :{ label : `Ok`, callback : async (html) => {             \n                                            let tmp = html.find(\"input[name='selection']\").get().filter(v => { if(v.checked) return true; }).map(e => { return e.value});\n                                            let exp = parseInt(html.find(\"input[name='experience'\")[0].value);\n                                            if(isNaN(exp) || tmp.length == 0) {\n                                                ui.notifications.error(\"Need a valid number of experience, either positive or negative\");\n                                                return;\n                                            }\n                                            addExperience(tmp,exp);\n                                        }\n                },\n            Cancel : {label : `Cancel`}\n        }\n    });\n    \n    x.options.width = 200;\n    x.position.width = 300;\n    \n    x.render(true);\n})();\n\nfunction addExperience(actorids, exp)\n{\n    let actorNames = \"\";\n    let updates = actorids.map(a => {\n        let aexp = game.actors.get(a);\n    \n        actorNames = actorNames + \"<li>\" + aexp.name;\n\n        return {\n            _id: a,\n            \"data.experience.total\": aexp.data.data.experience.total + exp\n        };\n    });\n    \n    Actor.updateDocuments(updates);\n    let chatOptions = {\n        rollMode: game.settings.get('core', 'rollMode'),        \n        content: `<h2>Experience change</h2> \n                    The following actors:<ul> ${actorNames}</ul> were awarded ${exp} experience`\n    };\n    ChatMessage.create(chatOptions);\n    // ui.notifications.info(`Added ${exp} experience to checked (${actorNames}) characters`);\n}",
      "flags": {
        "combat-utility-belt": {
          "macroTrigger": ""
        },
        "furnace": {
          "runAsGM": false
        },
        "core": {}
      },
      "ownership": {
        "default": 0,
        "IJbBQp9HIZhYkNtD": 3,
        "yBOfnkxE5pvS5PPZ": 3,
        "p6DS3gYz6OrQ6H9e": 3,
        "YsmQXJ6sqv5HM9Ov": 3
      },
      "_stats": {
        "systemId": "symbaroum",
        "systemVersion": "4.5.0",
        "coreVersion": "13.344",
        "createdTime": 1664296881889,
        "modifiedTime": 1717742554635,
        "lastModifiedBy": "YsmQXJ6sqv5HM9Ov",
        "compendiumSource": "Macro.Ib9lVNzgBhxjP5EZ",
        "duplicateSource": null,
        "exportSource": null
      },
      "folder": "Rudp3WGY5YPx13VV",
      "sort": 100000,
      "_id": "6iVCyY2HfY1K1v3t"
    },
    {
      "name": "Symbaroum.fr Character Importer",
      "type": "script",
      "author": "YsmQXJ6sqv5HM9Ov",
      "img": "icons/svg/up.svg",
      "scope": "global",
      "command": "/**\n * To use this macro, paste monster or player JSON data from symbaroum.fr\n * \n * Make sure you have all abilities, traits and powers in the \"Items\" in Foundry.\n * \n */\n\n(()=>{\n    let dialog_content = `  \n    <div class=\"symbaroum dialog\">\n        <div style=\"width:100%; text-align:center\">\n            <h3><a href=\"https://symbaroum.fr/#!/search\" target=\"_blank\">Symbaroum.fr</a> Character Importer</h3>\n        </div>\n        <div class=\"advantage\">\n            <label for=\"isplayer\">Player</label>\n            <span class=\"lblfavour\"><input type=\"checkbox\" id=\"isplayer\" name=\"isplayer\"></span>\n        </div>\n        <div class=\"advantage\">\n            <label for=\"npctext\">Paste json data</label>\n            <input name=\"npctext\" type=\"text\">\n        </div>\n    </div>`;\n\n    let x = new Dialog({\n        content : dialog_content,\n        buttons : \n        {\n            Ok : { label : `Ok`, \n            callback : \n            async (html)=> await extractAllData(html.find('[name=npctext]')[0].value.replace(/[\\r|\\n]/g, \"\"), html.find(\"#isplayer\")[0].checked)},\n            Cancel : {label : `Cancel`}\n        }\n    });\n    x.options.width = 400;\n    x.options.height = 400;\n    x.position.width = 400;\n    x.render(true);\n})();\n\nasync function extractAllData(json, player)\n{\n    // {\"nom\":\"Example for Bithir\",\"agi\":\"15\",\"forc\":\"13\",\"pre\":\"11\",\"vol\":\"10\",\"vig\":\"10\",\"dis\":\"9\",\"ast\":\"7\",\"per\":\"5\",\"ini\":\"\",\"typ\":\"Big Monster\",\"def\":\"15\",\"end\":\"13\",\"sd\":\"7\",\"sc\":\"5\",\"cp\":\"0\",\"deg\":\"Sword 1d8\",\"arm\":\"Light Armor 1d4\",\"notes\":\"Notes bout the character\",\"tactics\":\"Attack first, think last\",\"shadow\":\"Green with golden slashes\",\"equipment\":\"My equipment\",\"regles\":\"\",\"lang\":\"en\",\"epingles\":[\"Acrobatics\"],\"epinglesn\":[\"Bodyguard\"],\"epinglesa\":[\"Berserker\",\"Bodyguard\"],\"epinglesm\":[\"Iron fist\"]}\n    let symbfrJSON = null;\n    try {\n        symbfrJSON = JSON.parse(json);\n    } catch (err)\n    {\n        ui.notification.error(err);\n        return;\n    }\n    console.log(symbfrJSON, player);\n    let newValues = {\n        name: symbfrJSON.nom,\n        type: player ? \"player\": \"monster\",\n        folder: null,\n        sort: 12000,\n        data: {},\n        token: {},\n        items: [],\n        flags: {}        \n    }\n\n    setProperty(newValues, \"data.bio.manner\",\"\");\n\n    setProperty(newValues, \"data.bio.race\", symbfrJSON.typ);\n\n    setProperty(newValues, \"data.attributes.accurate.value\", parseInt(symbfrJSON.pre));\n    setProperty(newValues, \"data.attributes.cunning.value\", parseInt(symbfrJSON.ast));    \n    setProperty(newValues, \"data.attributes.discreet.value\", parseInt(symbfrJSON.dis));\n    setProperty(newValues, \"data.attributes.persuasive.value\", parseInt(symbfrJSON.per));\n    setProperty(newValues, \"data.attributes.quick.value\", parseInt(symbfrJSON.agi));\n    setProperty(newValues, \"data.attributes.resolute.value\", parseInt(symbfrJSON.vol));\n    setProperty(newValues, \"data.attributes.strong.value\", parseInt(symbfrJSON.forc));\n    setProperty(newValues, \"data.attributes.vigilant.value\", parseInt(symbfrJSON.vig));\n    setProperty(newValues, \"data.bio.shadow\", symbfrJSON.shadow);\n    setProperty(newValues, \"data.health.corruption.permanent\", parseInt(symbfrJSON.cp)); \n    setProperty(newValues, \"data.bio.tactics\", symbfrJSON.tactics);\n    setProperty(newValues, \"data.bio.background\", symbfrJSON.notes);\n\n    \n    let actor = await Actor.create(newValues);\n    console.log(actor);\n    let additionalInfo = \"\";\n    let items = [];\n    let itemIds = [];\n    additionalInfo += addPowers(symbfrJSON.epingles, items, 3, itemIds);\n    additionalInfo += addPowers(symbfrJSON.epinglesm, items, 3, itemIds);\n    additionalInfo += addPowers(symbfrJSON.epinglesa, items, 2, itemIds);\n    additionalInfo += addPowers(symbfrJSON.epinglesn, items, 1, itemIds);\n    // additionalInfo += addItems(symbfrJSON.equipment); - Just text\n    additionalInfo += addItems(symbfrJSON.deg, items, itemIds);\n    additionalInfo += addItems(symbfrJSON.arm, items, itemIds);\n\n    let updateObj = await actor.createEmbeddedDocuments(\"Item\", items);\n\n    let healMe = {_id:actor.id};\n    setProperty(healMe, \"data.health.toughness.value\", getProperty(actor, \"data.data.health.toughness.max\") );\n    await Actor.updateDocuments([healMe]);\n\n    let message = `Created ${actor.name}<br/>${additionalInfo}`;\n    ChatMessage.create({\n        speaker: ChatMessage.getSpeaker({alias: \"SymbFR Importer Macro\"}),\n        whisper: [game.user],\n        content: message\n    });\n\n\n    actor.sheet.render(true);\n}\n\nfunction addPowers(powernames, items, level, exclusions) {\n    let info = \"\";\n    for(let i = 0; i < powernames.length; i++) {\n        let powers = game.items.filter(element => element.name.trim().toLowerCase() === powernames[i].trim().toLowerCase() && element.data.isPower);\n        if(powers.length > 1) {\n            info += `Found more than one powers of ${powernames[i]}<br>`;\n        }    \n        for(let j = 0; j < powers.length; j++) {\n            let power = duplicate(powers[j].data);\n            if( exclusions.includes(power._id) ) {\n                continue;\n            }\n            console.log(\"Power\",powers[j]);\n            if(powers[j].data.hasLevels) {\n                if(level > 2)\n                    setProperty(power, \"data.master.isActive\",true);\n                if(level > 1)\n                    setProperty(power, \"data.adept.isActive\",true);\n                setProperty(power, \"data.novice.isActive\",true);\n            }\n            exclusions.push(power._id);\n            items.push(power);\n        }\n    }\n    return info;\n}\n\nfunction addItems(itemName, items, exclusions) {\n    // Exclusions ignored for now\n    let info = \"\";\n    itemName = itemName.replace(/([0-9]+d[0-9]+)/g,'').trim();\n    if( itemName == \"\") {\n        return;\n    }\n    let foundItems = game.items.filter(element => element.name.trim().toLowerCase() === itemName.toLowerCase() && !element.data.isPower);    \n    if(foundItems.length > 1) {\n        info += `Found more than one item of ${itemName}`;\n    }\n    for(let i = 0; i < foundItems.length; i++) {\n        let item = duplicate(foundItems[i].data);\n        items.push(item);\n    }\n    return info;\n}",
      "flags": {
        "core": {}
      },
      "ownership": {
        "default": 0,
        "IJbBQp9HIZhYkNtD": 3,
        "yBOfnkxE5pvS5PPZ": 3,
        "p6DS3gYz6OrQ6H9e": 3,
        "YsmQXJ6sqv5HM9Ov": 3
      },
      "_stats": {
        "systemId": "symbaroum",
        "systemVersion": "4.5.0",
        "coreVersion": "13.344",
        "createdTime": 1664296881889,
        "modifiedTime": 1717742554635,
        "lastModifiedBy": "YsmQXJ6sqv5HM9Ov",
        "compendiumSource": "Macro.UhAADqQtMSDxLa5X",
        "duplicateSource": null,
        "exportSource": null
      },
      "folder": "Rudp3WGY5YPx13VV",
      "sort": 200000,
      "_id": "LbWboJxC0cNYw9m0"
    },
    {
      "name": "Starter Set Character Importer",
      "type": "script",
      "author": "YsmQXJ6sqv5HM9Ov",
      "img": "icons/svg/mystery-man.svg",
      "scope": "global",
      "command": "/**\n * To use this macro, paste monster data from a pdf, for the starter set or haunted wastes:\n * including the name of the monster, to the end of the \"Tactics\" section\n * \n * If you use qpdfviewer - press 4 returns after the name\n * \n * \n * \n *  \n * Make sure you have all abilities, traits and powers in the \"Items\" in Foundry.\n * \n */\n\n// THIS IS WHAT YOU NEED\nconst countnl = (str) => {\n    const re = /[\\n\\r]/g\n    return ((str || '').match(re) || []).length\n}\n\nconst countother = (pattern, str) => {\n    const re = pattern\n    return ((str || '').match(re) || []).length\n}\n\nconst extractData = function(inputData, inputPattern) {\n    let tmp = inputData.match(inputPattern);\n    if( tmp != null && tmp.length >= 2) {\n        // successful match\n        return tmp[1];\n    }\n    return \"nomatch\";\n};\n\n\n\n(()=>{\n    let dialog_content = `  \n    <div class=\"symbaroum dialog\">\n        <div style=\"width:100%; text-align:center\">\n            <h3><a href=\"https://freeleaguepublishing.com/en/store/?product_id=7092044267669\" target=\"_blank\">Symbaroum Starter Set</a> Character Importer</h3>\n        </div>\n        <div class=\"advantage\">\n            <label for=\"isplayer\">Player</label>\n            <span class=\"lblfavour\"><input type=\"checkbox\" id=\"isplayer\" name=\"isplayer\"></span>\n        </div>\n        <div class=\"advantage\">\n            <label for=\"npctext\">Paste PDF data</label>\n            <textarea name=\"npctext\" type=\"text\" cols=30 rows=8></textarea>\n        </div>\n    </div>`;\n\n    let x = new Dialog({\n        content : dialog_content,\n        buttons : \n        {\n            Ok : { label : `Ok`, callback : async (html)=> await extractAllData(html.find('[name=npctext]')[0].value, html.find(\"#isplayer\")[0].checked)},\n            Cancel : {label : `Cancel`}\n        }\n    });\n\n    x.options.width = 400;\n    x.position.width = 400;\n\n    x.render(true);\n\n})();\n\nasync function extractWeapons(actorItems, type, weaponList)\n{\n    game.symbaroum.log(actorItems, type, weaponList);\n    if(weaponList !== null)\n    {\n\n    }\n    return \"\";\n}\n\nasync function extractSpecialItems(actorItems, type, abilitilist, abilityPattern)\n{\n    let message = \"\";\n    if( abilitilist !== null) {\n        await abilitilist.forEach(async element => { \n            let tmpdata = element.trim().match(abilityPattern);            \n            if( tmpdata != null && tmpdata.length == 3)\n            {\n                console.log(\"tmpdata = \",tmpdata);\n                let higherLevel = false;\n                let ability = game.items.filter(element => element.name.trim().toLowerCase() === tmpdata[1].trim().toLowerCase() && element.type === type);\n                if(ability.length > 0 )\n                {\n                    // console.log(\"ability=\"+JSON.stringify(ability));\n\n                    ability = duplicate(ability[0].data);\n                    let abilityAction = \"\";\n\n                    // Master ability\n                    if(tmpdata[2] === \"master\" || tmpdata[2] === \"III\") {                    \n                        higherLevel = true;\n                        setProperty(ability, \"data.master.isActive\",true);                                            \n                    }                \n                    abilityAction = getProperty(ability, \"data.master.action\");\n                    if( abilityAction === \"\") {\n                        setProperty(ability, \"data.master.action\", \"A\");\n                    }\n                    // Adept ability\n                    if(tmpdata[2] === \"adept\" || tmpdata[2] === \"II\" || higherLevel) {                \n                        higherLevel = true;\n                        setProperty(ability, \"data.adept.isActive\",true);                        \n\n                    }    \n                    abilityAction = getProperty(ability, \"data.adept.action\");\n                    if( abilityAction === \"\") {\n                        setProperty(ability, \"data.adept.action\", \"A\");\n                    }\n                    // Novice ability\n                    if(tmpdata[2] === \"novice\" || tmpdata[2] === \"I\" || higherLevel) {                              \n                        higherLevel = true;\n                        setProperty(ability, \"data.novice.isActive\",true);                        \n                    }\n                    abilityAction = getProperty(ability, \"data.novice.action\");\n                    if( abilityAction === \"\") {\n                        setProperty(ability, \"data.novice.action\", \"A\");\n                    }\n                    if( !higherLevel ) {\n                        message += `Could not establish level for ${ability.name} - change manually <br/>`;\n                    }\n                    // console.log(\"Final ability \"+JSON.stringify(ability));\n                    console.log(\"Added ability \"+ability.name)\n                    actorItems.push(ability);\n                }\n\n            }\n            else if( element.trim() !== \"\")\n            {\n                // message += `${element} not added - not found under Items - add manually <br/>`;\n                console.log(\"element[\"+element+\"] not found - add manually\");           \n            }\n        });\n\n    }    \n    return message;    \n}\n\nasync function extractAllData(npcData, player)\n{\n    let additionalInfo = \"\";\n\n    // Count new lines\n    if( countnl(npcData) > 3 ) {\n        npcData = npcData.replace(/[\\r|\\n]/, \" NLMARKER \");\n    } else {\n        // Find text after name - not sure this is doable - hack it for now?\n        // Recommendation is to \"have 4 linebreaks after name\"\n\n    }\n    expectedData = npcData.replace(/[\\r|\\n]/g, \" \");\n    expectedData = expectedData.replace(/[–−]/g, \"-\");\n    expectedData = expectedData.replace(/Integrated -?/g,\"\"); \n    // expectedData = expectedData.replace(/Abilities /g,\"\"); \n    // Hack\n    expectedData = expectedData.replace(/Traits -?/g,\"\"); \n    expectedData = expectedData.replace(/Abilities -/g,\"Abilities \");\n    // expectedData = expectedData.replace(/ ?[-]/g,\"\");\n    \n    console.log(expectedData);    \n\n    let namePattern = /^(.+?) (Race|Manner|NLMARKER)/;\n    let newValues = {\n        name: extractData(expectedData,namePattern),\n        type: player ? \"player\": \"monster\",\n        folder: null,\n        sort: 12000,\n        data: {},\n        token: {},\n        items: [],\n        flags: {}        \n    }\n\n    let mannerPattern = /resistance “(.*)”/;\n    setProperty(newValues, \"data.bio.manner\",extractData(expectedData,mannerPattern));\n\n    let racePattern = /NLMARKER (.*?), .* resistance/;\n    setProperty(newValues, \"data.bio.race\",extractData(expectedData,racePattern));\n\n    let myMatches = [];\n    console.log(\"My count other is \"+countother(/ACC CUN DIS PER QUI RES STR VIG/g,expectedData));\n    if( countother(/ACC CUN DIS PER QUI RES STR VIG/g,expectedData) == 1 ) {\n        // do it this way\n        myMatches = expectedData.match(/ACC CUN DIS PER QUI RES STR VIG ([-+]?[0-9]+) ([-+]?[0-9]+) ([-+]?[0-9]+) ([-+]?[0-9]+) ([-+]?[0-9]+) ([-+]?[0-9]+) ([-+]?[0-9]+) ([-+]?[0-9]+)/);\n        \n    } else {         \n        // do it the other way\n        myMatches = expectedData.match(/ACC ([-+]?[0-9]+) CUN ([-+]?[0-9]+) DIS ([-+]?[0-9]+) PER ([-+]?[0-9]+) QUI ([-+]?[0-9]+) RES ([-+]?[0-9]+) STR ([-+]?[0-9]+) VIG ([-+]?[0-9]+)/);\n    }\n    console.log(myMatches);\n    if(myMatches !== null && myMatches.length === 9 ) {\n        setProperty(newValues, \"data.attributes.accurate.value\", 10 - parseInt(myMatches[1]) );\n        setProperty(newValues, \"data.attributes.cunning.value\", 10 - parseInt(myMatches[2]) );    \n        setProperty(newValues, \"data.attributes.discreet.value\", 10 - parseInt(myMatches[3]) );    \n        setProperty(newValues, \"data.attributes.persuasive.value\", 10 - parseInt(myMatches[4]) );    \n        setProperty(newValues, \"data.attributes.quick.value\", 10 - parseInt(myMatches[5]) );    \n        setProperty(newValues, \"data.attributes.resolute.value\", 10 - parseInt(myMatches[6]) );    \n        setProperty(newValues, \"data.attributes.strong.value\", 10 - parseInt(myMatches[7]) );    \n        setProperty(newValues, \"data.attributes.vigilant.value\", 10 - parseInt(myMatches[8]) );    \n    } else {\n        additionalInfo += \"Could not find the attributes<br/>\";\n    }\n    let shadowPattern = /Shadow ([^\\(]*)/;\n    console.log(\"Shadow[\"+extractData(expectedData,shadowPattern)+\"]\");    \n    setProperty(newValues, \"data.bio.shadow\", extractData(expectedData,shadowPattern));\n    \n    // If nomatch == thouroughly corrupt\n    let corruptionPattern = /\\(corruption: ([0-9]+).?\\)/;\n    // console.log(\"Permanent Corruption[\"+extractData(expectedData,corruptionPattern)+\"]\");   \n    let corr = extractData(expectedData,corruptionPattern);\n    if( corr !== null && corr !== \"nomatch\" ) {\n        setProperty(newValues, \"data.health.corruption.permanent\", parseInt(extractData(expectedData,corruptionPattern))); \n    }\n    \n    let tacticsPattern = / Tactics: (.*)/;\n    console.log(\"Tactics[\"+extractData(expectedData,tacticsPattern)+\"]\");\n    setProperty(newValues, \"data.bio.tactics\", extractData(expectedData,tacticsPattern));\n\n    let actor = await Actor.create(newValues);\n\n    let abilitiesPattern = /Abilities(.+?) (Shadow|Equipment)/;\n    let singleAbilityPattern = /([^,^\\)]+?\\))?/g;\n    let abilityPattern = / ?([^\\(]+)\\((.+)\\)/;\n    let allAbilities = extractData(expectedData,abilitiesPattern);\n    // console.log(\"allAbilities:\"+allAbilities);\n    let abilitilist = allAbilities.match(singleAbilityPattern);\n    let actorItems = [];\n    // console.log(\"abilitylist:\"+abilitilist);\n\n    // Normal abilities\n    // Medicus (master), \n    additionalInfo += await extractSpecialItems(actorItems, \"ability\", abilitilist, abilityPattern);\n    additionalInfo += await extractSpecialItems(actorItems, \"mysticalPower\", abilitilist, abilityPattern);\n    additionalInfo += await extractSpecialItems(actorItems, \"trait\", abilitilist, abilityPattern);\n\n    // console.log(\"actorItems:\"+JSON.stringify(actorItems));\n    // Weapons\n    let weaponsPattern = /Weapons (.+?) (Abilities|Traits)/;\n    let singelWeaponPattern = / ?([^0-9]*)[0-9]+/g;\n    let allWeapons = extractData(expectedData,weaponsPattern);\n    game.symbaroum.log(\"allWeapons\", allWeapons)\n    additionalInfo += await extractWeapons(allWeapons, \"weapon\", abilitilist, singelWeaponPattern);\n\n    let updateObj = await actor.createEmbeddedDocuments(\"Item\", actorItems);\n    // console.log(\"updateObj \"+JSON.stringify(updateObj));\n\n\n    let healMe = {_id:actor.id};\n    setProperty(healMe, \"data.health.toughness.value\", getProperty(actor, \"data.data.health.toughness.max\") );\n    await Actor.updateDocuments([healMe]);\n\n    let message = `Created ${actor.name}<br/>${additionalInfo}`;\n    ChatMessage.create({\n        speaker: ChatMessage.getSpeaker({alias: \"Character Importer Macro\"}),\n        whisper: [game.user],\n        content: message\n    });\n    actor.sheet.render(true);\n}",
      "flags": {
        "furnace": {
          "runAsGM": false
        },
        "combat-utility-belt": {
          "macroTrigger": ""
        },
        "core": {}
      },
      "ownership": {
        "default": 0,
        "IJbBQp9HIZhYkNtD": 3,
        "yBOfnkxE5pvS5PPZ": 3,
        "p6DS3gYz6OrQ6H9e": 3,
        "YsmQXJ6sqv5HM9Ov": 3
      },
      "_stats": {
        "systemId": "symbaroum",
        "systemVersion": "4.5.0",
        "coreVersion": "13.344",
        "createdTime": 1664296881889,
        "modifiedTime": 1717742554635,
        "lastModifiedBy": "YsmQXJ6sqv5HM9Ov",
        "compendiumSource": "Macro.rovDHjS4ZPvgmWZM",
        "duplicateSource": null,
        "exportSource": null
      },
      "folder": "Rudp3WGY5YPx13VV",
      "sort": 300000,
      "_id": "QKrCYf9rnqnhvzF2"
    },
    {
      "name": "Roll Attribute",
      "type": "script",
      "author": "YsmQXJ6sqv5HM9Ov",
      "img": "icons/svg/dice-target.svg",
      "scope": "global",
      "command": "(()=>{\n    let defaultCheck = \"unchecked\"; // set to unchecked\n    let actorslist = [];\n\n    if(canvas.tokens.controlled.length > 0) {\n        // If no actor selected\n        // Time to get busy\n        canvas.tokens.controlled.map(e => { \n            if(e.actor.data.type === \"player\") {\n                if(game.user.isGM || e.actor.owner)\n                    actorslist.push(e.actor);\n            }\n        });\n        if(actorslist.length > 0 ) { actorslist = [actorslist[0]]; }\n        // check if there are tokens on the map, if so, use their actors\n        // if there are no controlled tokens on the map, select all players in the actor catalogue\n    } else {     \n        let gameacts = game.actors.filter(e => { if( (game.user.isGM || e.owner) && e.data.type === \"player\") { return e; } });\n        Array.prototype.push.apply(actorslist, gameacts);\n    }\n\n    if(actorslist.length === 0) {\n        ui.notifications.info(`No actor available for you to do an attribute test`);\n        return;\n    } else if(actorslist.length === 1) {\n        defaultCheck = \"checked\";\n    }\n\n    let allActors = \"\";\n    actorslist.forEach(t => {\n        allActors = allActors.concat(`<div style=\"flex-basis: auto;flex-direction: row;display: flex;\">\n                <div style=\"width:10em;min-width:10em;\"><label for=\"${t.data._id}\">${t.data.name}</label> </div>\n                <div><input id=\"${t.data._id}\" type=\"radio\" name=\"selection\" value=\"${t.data._id}\" ${defaultCheck}=\"${defaultCheck}\"></div>\n            </div>`);\n    });\n    \n    let keys = Object.keys(actorslist[0].data.data.attributes);\n    let allKeys = \"\";\n    keys.forEach(t => {\n        allKeys = allKeys.concat(`<option value=\"${t}\">${game.i18n.localize(actorslist[0].data.data.attributes[t].label)}`);\n    });\n\n    let dialog_content = `  \n    <div class=\"form-group\">\n    <h2>Select player(s)</h2>\n    ${allActors}\n    <br />\n    <div style=\"flex-basis: auto;flex-direction: row;display: flex;\">\n    <div style=\"width:10em;min-width:10em;\"><label for=\"attribute\" style=\"min-width:10em\">${game.i18n.localize(\"DIALOG.ATTRIBUTE\")}</label> </div>\n    <div style=\"width:10em;min-width:10em;\"><select id=\"attribute\" name=\"category\">${allKeys}</select></div>\n    </div><br/>\n    </div>`;\n\n    let x = new Dialog({\n        content : dialog_content,\n        alternatives: keys,\n        buttons : \n        {\n        Ok : { label : `Ok`, callback : async (html)=> {\n                let tmp = html.find(\"input[name='selection']\").get().filter(v => { if(v.checked) return true; }).map(e => { return e.value});\n                await rollAttribute(tmp, html.find('#attribute')[0].value);\n            }\n        },\n        Cancel : {label : `Cancel`}\n        }\n    });\n    \n    x.options.width = 200;\n    x.position.width = 300;\n    \n    x.render(true);\n})();\n\nasync function rollAttribute(actorids, attribute)\n{\n    let updates = actorids.map(a => {\n        let aexp = game.actors.get(a);\n        aexp.rollAttribute(attribute, null, null);\n    });\n}",
      "flags": {
        "combat-utility-belt": {
          "macroTrigger": ""
        },
        "furnace": {
          "runAsGM": false
        },
        "core": {}
      },
      "ownership": {
        "default": 0,
        "IJbBQp9HIZhYkNtD": 3,
        "yBOfnkxE5pvS5PPZ": 3,
        "p6DS3gYz6OrQ6H9e": 3,
        "YsmQXJ6sqv5HM9Ov": 3
      },
      "_stats": {
        "systemId": "symbaroum",
        "systemVersion": "4.5.0",
        "coreVersion": "13.344",
        "createdTime": 1664296881889,
        "modifiedTime": 1717742554635,
        "lastModifiedBy": "YsmQXJ6sqv5HM9Ov",
        "compendiumSource": "Macro.jqlw2EhoIe8KhTuu",
        "duplicateSource": null,
        "exportSource": null
      },
      "folder": "Rudp3WGY5YPx13VV",
      "sort": 400000,
      "_id": "WfW4MIeC2WByOpVh"
    },
    {
      "name": "Alternate Damage",
      "type": "script",
      "author": "YsmQXJ6sqv5HM9Ov",
      "img": "icons/svg/stoned.svg",
      "scope": "global",
      "command": "if (canvas.tokens.controlled.length === 0)\n  return ui.notifications.error(\"Please select a token first\");\n\nnew Dialog({\n  title: `Alternate Damage`,\n  content: `\n    <form>\n    <div style=\"display:flex\">\n    <label style=\"min-width:15em\" for=\"damagetype\">Damage type:</label>\n    <select id=\"vision-type\" style=\"min-width:10em\" name=\"damagetype\">\n    <option value=\"accurate\">${game.i18n.localize(\"ATTRIBUTE.ACCURATE\")}</option>\n    <option value=\"cunning\">${game.i18n.localize(\"ATTRIBUTE.CUNNING\")}</option>\n    <option value=\"discreet\">${game.i18n.localize(\"ATTRIBUTE.DISCREET\")}</option>\n    <option value=\"persuasive\">${game.i18n.localize(\"ATTRIBUTE.PERSUASIVE\")}</option>\n    <option value=\"quick\">${game.i18n.localize(\"ATTRIBUTE.QUICK\")}</option>\n    <option value=\"resolute\">${game.i18n.localize(\"ATTRIBUTE.RESOLUTE\")}</option>\n    <option value=\"strong\">${game.i18n.localize(\"ATTRIBUTE.STRONG\")}</option>\n    <option value=\"vigilant\">${game.i18n.localize(\"ATTRIBUTE.VIGILANT\")}</option>    \n    </select>\n    </div>\n    <div style=\"display:flex; margin-top:5px; margin-bottom:5px\">\n    <label style=\"min-width:15em\" for=\"altdam\">Damage:</label>\n    <input style=\"max-width:10em\" id=\"altdam\" name=\"altdam\" type=\"text\">\n    </div>\n    </form>\n    `,\n  buttons: {\n    yes: {\n      icon: \"<i class='fas fa-check'></i>\",\n      label: `Apply Damage`,\n      callback: async (html)=> {\n          await dealDamage(html.find(\"#vision-type\")[0].value, html.find('#altdam')[0].value);\n        }\n    },\n    no: {\n      icon: \"<i class='fas fa-times'></i>\",\n      label: `Cancel Damage`\n    },\n  },\n  default: \"yes\",\n}).render(true);\n\nasync function dealDamage(type, damage)\n{\n    for ( let token of canvas.tokens.controlled ) {\n        let calcDam = parseInt(damage) * -1;\n        if( isNaN(calcDam)) {\n            console.log(\"Can't understand damage[\"+damage+\"] - is this a number?\");\n            break;\n        }\n        let actor = token.actor;\n        if( actor.data.data.attributes[type] === undefined || actor.data.data.attributes[type] === null) {\n            console.log(\"This is not an attribute in Symbaroum\");\n            break;\n        }\n        let tot = actor.data.data.attributes[type].temporaryMod + calcDam;\n        let modification = {        };\n        setProperty(modification, `data.attributes.${type}.temporaryMod`, tot);        \n        await actor.update(modification);\n    }\n}",
      "flags": {
        "combat-utility-belt": {
          "macroTrigger": ""
        },
        "furnace": {
          "runAsGM": false
        },
        "core": {}
      },
      "ownership": {
        "default": 0,
        "IJbBQp9HIZhYkNtD": 3,
        "yBOfnkxE5pvS5PPZ": 3,
        "p6DS3gYz6OrQ6H9e": 3,
        "YsmQXJ6sqv5HM9Ov": 3
      },
      "_stats": {
        "systemId": "symbaroum",
        "systemVersion": "4.5.0",
        "coreVersion": "13.344",
        "createdTime": 1664298196637,
        "modifiedTime": 1717742554635,
        "lastModifiedBy": "YsmQXJ6sqv5HM9Ov",
        "compendiumSource": "Macro.8cLkjnA8FBNnVMOm",
        "duplicateSource": null,
        "exportSource": null
      },
      "folder": "Rudp3WGY5YPx13VV",
      "sort": 600000,
      "_id": "ZSV96pxBgFmBjZhi"
    },
    {
      "name": "CRB Character Importer",
      "type": "script",
      "author": "YsmQXJ6sqv5HM9Ov",
      "img": "icons/svg/mystery-man.svg",
      "scope": "global",
      "command": "/**\n * To use this macro, paste monster data from a pdf, for the core book:\n * including the name of the monster, to the end of the \"Tactics\" section\n * \n * For the monster codex, manually type in the name, then copy from Manners to end of tactics and paste.\n * Warning: the tilted character sheet can cause issues, depending on your pdf viewer, you might need to do those manually.\n * \n * WARNING: If you have multiple items that matches the name of abilities, traits and mystical powers, they might be found instead.\n *  \n * Make sure you have all abilities, traits and powers in the \"Items\" in Foundry.\n * \n */\n\n(()=>{\n    let dialog_content = `  \n    <div class=\"symbaroum dialog\">\n        <div style=\"width:100%; text-align:center\">\n            <h3><a href=\"https://freeleaguepublishing.com/en/store/?product_id=7092032045205\" target=\"_blank\">Symbaroum Core Book</a> Character Importer</h3>\n        </div>\n        <div class=\"advantage\">\n            <label for=\"isplayer\">Player</label>\n            <span class=\"lblfavour\"><input type=\"checkbox\" id=\"isplayer\" name=\"isplayer\"></span>\n        </div>\n        <div class=\"advantage\">\n            <label for=\"npctext\">Paste PDF data</label>\n            <input name=\"npctext\" type=\"text\">\n        </div>\n    </div>`;\n\n    let x = new Dialog({\n        content : dialog_content,\n        buttons : \n        {\n            Ok : { label : `Ok`, callback : async (html)=> await extractAllData(html.find('[name=npctext]')[0].value.replace(/[\\r|\\n]/g, \"\"), html.find(\"#isplayer\")[0].checked)},\n            Cancel : {label : `Cancel`}\n        }\n    });\n\n    x.options.width = 400;\n    x.position.width = 400;\n\n    x.render(true);\n\n})();\n\nasync function extractSpecialItems(actorItems, type, abilitilist, abilityPattern)\n{\n    let message = \"\";\n    if( abilitilist !== null) {\n        await abilitilist.forEach(async element => { \n            let tmpdata = element.trim().match(abilityPattern);\n            // console.log(\"tmpdata = \"+tmpdata);\n            if( tmpdata != null && tmpdata.length == 3)\n            {\n                let higherLevel = false;\n                let ability = game.items.filter(element => element.name.trim().toLowerCase() === tmpdata[1].trim().toLowerCase() && element.type === type);                \n                if(ability.length > 0 )\n                {\n                    // console.log(\"ability=\"+JSON.stringify(ability));\n\n                    ability = duplicate(ability[0].data);\n                    let abilityAction = \"\";\n\n                    // Master ability\n                    if(tmpdata[2] === \"master\" || tmpdata[2] === \"III\") {                    \n                        higherLevel = true;\n                        setProperty(ability, \"data.master.isActive\",true);                                            \n                    }                \n                    abilityAction = getProperty(ability, \"data.master.action\");\n                    if( abilityAction === \"\") {\n                        setProperty(ability, \"data.master.action\", \"A\");\n                    }\n                    // Adept ability\n                    if(tmpdata[2] === \"adept\" || tmpdata[2] === \"II\" || higherLevel) {                \n                        higherLevel = true;\n                        setProperty(ability, \"data.adept.isActive\",true);                        \n\n                    }    \n                    abilityAction = getProperty(ability, \"data.adept.action\");\n                    if( abilityAction === \"\") {\n                        setProperty(ability, \"data.adept.action\", \"A\");\n                    }\n                    // Novice ability\n                    if(tmpdata[2] === \"novice\" || tmpdata[2] === \"I\" || higherLevel) {                              \n                        setProperty(ability, \"data.novice.isActive\",true);                        \n                    }\n                    abilityAction = getProperty(ability, \"data.novice.action\");\n                    if( abilityAction === \"\") {\n                        setProperty(ability, \"data.novice.action\", \"A\");\n                    }\n                    // console.log(\"Final ability \"+JSON.stringify(ability));\n                    console.log(\"Added ability \"+ability.name)\n                    actorItems.push(ability);\n                }\n                else if( type !== \"mysticalPower\" && type !== \"ability\" )\n                {\n                    message += `${element} not added as ${type} - add manually if needed <br/>`;\n                }\n            }\n            else if( element.trim() !== \"\")\n            {\n                // message += `${element} not added - not found under Items - add manually <br/>`;\n                console.log(\"element[\"+element+\"] not found - add manually\");           \n            }\n        });\n\n    }    \n    return message;    \n}\n\nasync function extractAllData(npcData, player)\n{\n    let additionalInfo = \"\";\n\n    let extractData = function(inputData, inputPattern) {\n        let tmp = inputData.match(inputPattern);\n        if( tmp != null && tmp.length >= 2) {\n            // successful match\n            return tmp[1];\n        }\n        return \"nomatch\";\n    };\n    let expectedData = npcData.replace(/- /g,\"\");\n\n    let namePattern = /^(.+?) (Race|Manner)/;\n    let newValues = {\n        name: extractData(expectedData,namePattern),\n        type: player ? \"player\": \"monster\",\n        folder: null,\n        sort: 12000,\n        data: {},\n        token: {},\n        items: [],\n        flags: {}        \n    }\n\n    let mannerPattern = /Manner (.*) Race /;\n    setProperty(newValues, \"data.bio.manner\",extractData(expectedData,mannerPattern));\n\n    let racePattern = /Race (.*) Resistance/;\n    setProperty(newValues, \"data.bio.race\",extractData(expectedData,racePattern));\n\n    let attributePattern = /Accurate ([0-9]+)/;\n    // console.log(\"Accurate[\"+extractData(expectedData,attributePattern)+\"]\");\n    setProperty(newValues, \"data.attributes.accurate.value\", parseInt(extractData(expectedData,attributePattern)));\n    attributePattern = /Cunning ([0-9]+)/;\n    // console.log(\"Cunning[\"+extractData(expectedData,attributePattern)+\"]\");\n    setProperty(newValues, \"data.attributes.cunning.value\", parseInt(extractData(expectedData,attributePattern)));    \n    attributePattern = /Discreet ([0-9]+)/;\n    // console.log(\"Discreet[\"+extractData(expectedData,attributePattern)+\"]\");\n    setProperty(newValues, \"data.attributes.discreet.value\", parseInt(extractData(expectedData,attributePattern)));\n    attributePattern = /Persuasive ([0-9]+)/;\n    // console.log(\"Persuasive[\"+extractData(expectedData,attributePattern)+\"]\");\n    setProperty(newValues, \"data.attributes.persuasive.value\", parseInt(extractData(expectedData,attributePattern)));\n    attributePattern = /Quick ([0-9]+).+\\)/;\n    // console.log(\"Quick[\"+extractData(expectedData,attributePattern)+\"]\");\n    setProperty(newValues, \"data.attributes.quick.value\", parseInt(extractData(expectedData,attributePattern)));\n    attributePattern = /Resolute ([0-9]+)/;\n    // console.log(\"Resolute[\"+extractData(expectedData,attributePattern)+\"]\");\n    setProperty(newValues, \"data.attributes.resolute.value\", parseInt(extractData(expectedData,attributePattern)));\n    attributePattern = /Strong ([0-9]+)/;\n    // console.log(\"Strong[\"+extractData(expectedData,attributePattern)+\"]\");\n    setProperty(newValues, \"data.attributes.strong.value\", parseInt(extractData(expectedData,attributePattern)));\n    attributePattern = /Vigilant ([0-9]+)/;\n    // console.log(\"Vigilant[\"+extractData(expectedData,attributePattern)+\"]\");\n    setProperty(newValues, \"data.attributes.vigilant.value\", parseInt(extractData(expectedData,attributePattern)));\n\n    let shadowPattern = /Shadow (.*) \\(/;\n    // console.log(\"Shadow[\"+extractData(expectedData,shadowPattern)+\"]\");    \n    setProperty(newValues, \"data.bio.shadow\", extractData(expectedData,shadowPattern));\n    \n    // If nomatch == thouroughly corrupt\n    let corruptionPattern = /\\(corruption: ([0-9]+).?\\)/;\n    // console.log(\"Permanent Corruption[\"+extractData(expectedData,corruptionPattern)+\"]\");   \n    let corr = extractData(expectedData,corruptionPattern);\n    if( corr !== null && corr !== \"nomatch\" ) {\n        setProperty(newValues, \"data.health.corruption.permanent\", parseInt(extractData(expectedData,corruptionPattern))); \n    }\n    \n    let tacticsPattern = / Tactics: (.*)/;\n    // console.log(\"Tactics[\"+extractData(expectedData,tacticsPattern)+\"]\");\n    setProperty(newValues, \"data.bio.tactics\", extractData(expectedData,tacticsPattern));\n\n    let actor = await Actor.create(newValues);\n\n    let abilitiesPattern = /Abilities (.+?) Weapons /;\n    let singleAbilityPattern = /([^,^\\)]+?\\))?/g;\n    let abilityPattern = / ?([^\\(]+)\\((.+)\\)/;\n    let allAbilities = extractData(expectedData,abilitiesPattern);\n    console.log(\"allAbilities:\"+allAbilities);\n    let abilitilist = allAbilities.match(singleAbilityPattern);\n    let actorItems = [];\n    console.log(\"abilitylist:\"+abilitilist);\n\n    // Normal abilities\n    // Medicus (master), \n    additionalInfo += await extractSpecialItems(actorItems, \"ability\", abilitilist, abilityPattern);\n    additionalInfo += await extractSpecialItems(actorItems, \"mysticalPower\", abilitilist, abilityPattern);\n    // Mystical Power\n    // let mysticalPowerPattern = /Mystical [Pp]ower \\(([^,]+), ([^\\)]*)\\)/g;\n    let singleMysticalPowerPattern = /Mystical [Pp]ower \\(([^\\)]*)\\)/g;\n    abilitilist = allAbilities.match(singleMysticalPowerPattern);\n    let mysticalPowerPattern = /\\(([^,]+), (.*)\\)/\n    console.log(\"abilitylist[mp]:\"+JSON.stringify(abilitilist));\n    // Mystical Power (Bend Will, master)\n    additionalInfo += await extractSpecialItems(actorItems, \"mysticalPower\", abilitilist, mysticalPowerPattern);\n\n    let traitsPattern = /Traits (.+) Accurate [0-9]/;\n    console.log(\"Traits[\"+extractData(expectedData,traitsPattern)+\"]\");\n    let traitstlist = extractData(expectedData,traitsPattern).match(singleAbilityPattern);\n    // console.log(\"traitslist =\"+JSON.stringify(traitstlist));\n    additionalInfo += await extractSpecialItems(actorItems, \"trait\", traitstlist, abilityPattern);\n\n    // console.log(\"actorItems:\"+JSON.stringify(actorItems));\n\n    let updateObj = await actor.createEmbeddedDocuments(\"Item\", actorItems);\n    // console.log(\"updateObj \"+JSON.stringify(updateObj));\n\n\n    let healMe = {_id:actor.id};\n    setProperty(healMe, \"data.health.toughness.value\", getProperty(actor, \"data.data.health.toughness.max\") );\n    await Actor.updateDocuments([healMe]);\n\n    let message = `Created ${actor.name}<br/>${additionalInfo}`;\n    ChatMessage.create({\n        speaker: ChatMessage.getSpeaker({alias: \"Character Importer Macro\"}),\n        whisper: [game.user],\n        content: message\n    });\n\n    actor.sheet.render(true);\n}",
      "flags": {
        "furnace": {
          "runAsGM": false
        },
        "combat-utility-belt": {
          "macroTrigger": ""
        },
        "core": {}
      },
      "ownership": {
        "default": 0,
        "IJbBQp9HIZhYkNtD": 3,
        "yBOfnkxE5pvS5PPZ": 3,
        "p6DS3gYz6OrQ6H9e": 3,
        "YsmQXJ6sqv5HM9Ov": 3
      },
      "_stats": {
        "systemId": "symbaroum",
        "systemVersion": "4.5.0",
        "coreVersion": "13.344",
        "createdTime": 1664298196638,
        "modifiedTime": 1717742554635,
        "lastModifiedBy": "YsmQXJ6sqv5HM9Ov",
        "compendiumSource": "Macro.rovDHjS4ZPvgmWZM",
        "duplicateSource": null,
        "exportSource": null
      },
      "folder": "Rudp3WGY5YPx13VV",
      "sort": 700000,
      "_id": "Dad9wDMF4RbV5gUi"
    },
    {
      "name": "Reset Temporary Corruption",
      "type": "script",
      "author": "YsmQXJ6sqv5HM9Ov",
      "img": "icons/svg/ice-aura.svg",
      "scope": "global",
      "command": "/** \n * Macro can be used by either selecting tokens on-screen or, if no tokens are selected, choosing which player characters (default all)\n * \n */\n (()=>{\n    let defaultCheck = \"checked\"; // set to unchecked\n    let actorslist = [];\n\n    if(canvas.tokens.controlled.length > 0) {\n        // If no actor selected\n        // Time to get busy\n        canvas.tokens.controlled.map(e => { \n            if(e.actor.data.type === \"player\") {\n                if(game.user.isGM || e.actor.owner)\n                    actorslist.push(e.actor);\n            }\n        });\n        if(actorslist.length > 0 ) \n        {\n            actorslist = [actorslist[0]];\n        }\n    } else {     \n        let gameacts = game.actors.filter(e => { if( (game.user.isGM || e.owner) && e.data.type === \"player\") { return e; } });\n        Array.prototype.push.apply(actorslist, gameacts);\n    }\n\n    let allKeys = \"\";\n    actorslist.forEach(t => {\n        allKeys = allKeys.concat(`<div style=\"flex-basis: auto;flex-direction: row;display: flex;\">\n                <div style=\"width:10em;min-width:10em;\"><label for=\"${t.data._id}\">${t.data.name}</label> </div>\n                <div><input id=\"${t.data._id}\" type=\"checkbox\" name=\"selection\" value=\"${t.data._id}\" ${defaultCheck}=\"${defaultCheck}\"></div>\n            </div>`);\n    });\n\n    let dialog_content = `  \n    <div class=\"form-group\">\n    <h2>Select player(s)</h2>\n    ${allKeys}\n    <br />\n    </div>`;\n    let x = new Dialog({\n        title: \"Reset Corruption\",\n        content : dialog_content,\n        buttons : \n        {\n            Ok :{ label : `Ok`, callback : async (html) => {             \n                                            let tmp = html.find(\"input[name='selection']\").get().filter(v => { if(v.checked) return true; }).map(e => { return e.value});                                            \n                                            if(tmp.length == 0) {\n                                                ui.notifications.error(\"Need a valid number of players\");\n                                                return;\n                                            }\n                                            resetCorruption(tmp);\n                                        }\n                },\n            Cancel : {label : `Cancel`}\n        }\n    });\n    \n    x.options.width = 200;\n    x.position.width = 300;\n    \n    x.render(true);\n})();\n\nfunction resetCorruption(actorids)\n{\n    let actorNames = \"\";\n    let updates = actorids.map(a => {\n        let aexp = game.actors.get(a);\n    \n        actorNames = actorNames + \"<li>\" + aexp.name;\n\n        return {\n            _id: a,\n            \"data.health.corruption.temporary\": 0\n        };\n    });\n    \n    Actor.updateDocuments(updates);\n    let chatOptions = {\n        rollMode: game.settings.get('core', 'rollMode'),        \n        content: `<h2>Temporary corruption was washed away</h2> \n                    The following actors:<ul> ${actorNames}</ul> is now at zero temporary corruption`\n    };\n    ChatMessage.create(chatOptions);\n    // ui.notifications.info(`Added ${exp} experience to checked (${actorNames}) characters`);\n}",
      "flags": {
        "furnace": {
          "runAsGM": false
        },
        "core": {}
      },
      "ownership": {
        "default": 0,
        "IJbBQp9HIZhYkNtD": 3,
        "yBOfnkxE5pvS5PPZ": 3,
        "p6DS3gYz6OrQ6H9e": 3,
        "YsmQXJ6sqv5HM9Ov": 3
      },
      "_stats": {
        "systemId": "symbaroum",
        "systemVersion": "4.5.0",
        "coreVersion": "13.344",
        "createdTime": 1664298196639,
        "modifiedTime": 1717742554635,
        "lastModifiedBy": "YsmQXJ6sqv5HM9Ov",
        "compendiumSource": "Macro.rfxvvcoQfLNQNd4L",
        "duplicateSource": null,
        "exportSource": null
      },
      "folder": "Rudp3WGY5YPx13VV",
      "sort": 800000,
      "_id": "NP4vptIEn0E6BNPJ"
    },
    {
      "name": "Toggle player/monster",
      "type": "script",
      "author": "YsmQXJ6sqv5HM9Ov",
      "img": "icons/svg/bones.svg",
      "scope": "global",
      "command": "// Make a monster a PC, make a PC a monster\n(()=>{\n    let dialog_content = `  \n    <div class=\"form-group\">\n        Type the exact name of the player/npc - ensure the Player/NPC has a unique name among all your actors.  <br/> A NPC will be made into a player. A player will be made into an NPC.<br/>\n      <label for=\"npctext\">NPC name</label>\n      <input name=\"npctext\" type=\"text\">\n    </div>`;\n  \n    let x = new Dialog({\n      content : dialog_content,\n      buttons : \n      {\n        Ok : { label : `Ok`, callback : async (html)=> await change2PC(html.find('[name=npctext]')[0].value.replace(/[\\r|\\n]/g, \"\"))},\n        Cancel : {label : `Cancel`}\n      }\n    });\n  \n    x.options.width = 200;\n    x.position.width = 200;\n  \n    x.render(true);\n  \n})();\n\nasync function change2PC(npcname)\n{\n    let myActor = game.actors.getName(npcname);\n    console.log(myActor);\n    if( myActor === null) {\n        ui.notifications.error(`Could not find actor with name ${npcname}. Try again`);\n        return;\n    }\n    let update = { \n        type : myActor.type === \"player\" ? \"monster\":\"player\"\n    };\n    await myActor.update(update);\n    ui.notifications.info(`Actor with name ${npcname} is now a ${update.type}.`);\n}",
      "flags": {
        "combat-utility-belt": {
          "macroTrigger": ""
        },
        "furnace": {
          "runAsGM": false
        },
        "core": {}
      },
      "ownership": {
        "default": 0,
        "IJbBQp9HIZhYkNtD": 3,
        "yBOfnkxE5pvS5PPZ": 3,
        "p6DS3gYz6OrQ6H9e": 3,
        "YsmQXJ6sqv5HM9Ov": 3
      },
      "_stats": {
        "systemId": "symbaroum",
        "systemVersion": "4.5.0",
        "coreVersion": "13.344",
        "createdTime": 1664298196641,
        "modifiedTime": 1717742554635,
        "lastModifiedBy": "YsmQXJ6sqv5HM9Ov",
        "compendiumSource": "Macro.pyfWvOpMN1B6lcLS",
        "duplicateSource": null,
        "exportSource": null
      },
      "folder": "Rudp3WGY5YPx13VV",
      "sort": 900000,
      "_id": "M5nKpqxe6XQjiJUg"
    },
    {
      "name": "Pay for re-roll",
      "type": "script",
      "author": "YsmQXJ6sqv5HM9Ov",
      "img": "icons/svg/d20-grey.svg",
      "scope": "global",
      "command": "/** \n * Macro can be used by either selecting tokens on-screen or, if no tokens are selected, choosing which player characters (default all)\n * \n */\n (()=>{\n    let defaultCheck = \"unchecked\"; // set to unchecked\n    let bithirsGame = false; // It is not a bithir world unless this is set\n    let actorslist = [];\n\n    if(canvas.tokens.controlled.length > 0) {\n        // If no actor selected\n        // Time to get busy\n        canvas.tokens.controlled.map(e => { \n            if(e.actor.data.type === \"player\") {\n                if(game.user.isGM || e.actor.owner)\n                    actorslist.push(e.actor);\n            }\n        });\n        if(actorslist.length > 0 ) { actorslist = [actorslist[0]]; }\n        // check if there are tokens on the map, if so, use their actors\n        // if there are no controlled tokens on the map, select all players in the actor catalogue\n    } else {     \n        let gameacts = game.actors.filter(e => { if( (game.user.isGM || e.owner) && e.data.type === \"player\") { return e; } });\n        Array.prototype.push.apply(actorslist, gameacts);\n    }\n    \n\n    if(actorslist.length === 0) {\n        ui.notifications.info(`No actor available for you to apply re-roll cost`);\n        return;\n    } else if(actorslist.length === 1) {\n        defaultCheck = \"checked\";\n    }    \n\n    let allKeys = \"\";\n    actorslist.forEach(t => {\n        allKeys = allKeys.concat(`<div style=\"flex-basis: auto;flex-direction: row;display: flex;\">\n                <div style=\"width:10em;min-width:10em;\"><label for=\"${t.data._id}\">${t.data.name}</label> </div>\n                <div><input id=\"${t.data._id}\" type=\"radio\" name=\"selection\" value=\"${t.data._id}\" ${defaultCheck}=\"${defaultCheck}\"></div>\n            </div>`);\n    });\n\n    let dialog_content = `  \n    <div class=\"form-group\">\n    <h2>Select player(s)</h2>\n    ${allKeys}\n    <br />\n    <div>Select what was used for the re-roll</div>\n    <div style=\"flex-basis: auto;flex-direction: row;display: flex;\">\n        <div style=\"width:10em;min-width:10em;\"><label for=\"artifactrr\">Experience</label> </div>\n        <div><input type=\"radio\" id=\"artifactrr\" value=\"artifactrr\" name=\"costType\"></div>\n    </div>\n    <div style=\"flex-basis: auto;flex-direction: row;display: flex;\">\n        <div style=\"width:10em;min-width:10em;\"><label for=\"permanent\">Corruption (perm)</label></div>\n        <div><input type=\"radio\" id=\"permanent\" value=\"permanent\" name=\"costType\"></div>\n    </div>`;\n    if(bithirsGame) {\n        dialog_content = dialog_content + `<div style=\"flex-basis: auto;flex-direction: row;display: flex;\">\n        <div style=\"width:10em;min-width:10em;\"><label for=\"permanent\">Corruption (daily)</label></div>\n        <div><input type=\"radio\" id=\"longterm\" value=\"longterm\" name=\"costType\"></div>\n        </div>`;\n    }\n    dialog_content += `<br /></div>`;\n    let x = new Dialog({\n        title: \"Take cost for re-roll\",\n        content : dialog_content,\n        buttons : \n        {\n            Ok :{ label : `Ok`, callback : async (html) => {             \n                                            let tmp = html.find(\"input[name='selection']\").get().filter(v => { if(v.checked) return true; }).map(e => { return e.value});\n                                            let costType = html.find(\"input[name='costType']\").get().filter(v => { if(v.checked) return true; }).map(e => { return e.value});\n\n                                            await payCost(tmp,costType);\n                                        }\n                },\n            Cancel : {label : `Cancel`}\n        }\n    });\n    \n    x.options.width = 200;\n    x.position.width = 300;\n    \n    x.render(true);\n})();\n\nasync function payCost(actorids, costType)\n{\n    let aexp = null;\n    let actorName = \"\";\n    \n    let message_content = \"\";\n    let dice = new Roll(\"1d4\");\n    dice.evaluate({async:false});\n\n    let updates = actorids.map(a => {\n        aexp = game.actors.get(a);\n        actorName = aexp.name;        \n        return {\n            _id: a,\n            \"data.experience.artifactrr\": aexp.data.data.experience.artifactrr + ( costType.includes(\"artifactrr\")? 1:0),\n            \"data.health.corruption.permanent\": aexp.data.data.health.corruption.permanent + ( costType.includes(\"permanent\")? 1:0),\n            \"data.health.corruption.longterm\": aexp.data.data.health.corruption.longterm + ( costType.includes(\"longterm\")? dice.total:0)\n        };\n    });\n    // console.log(updates);\n    let chatOptions = {\n        speaker: \n        {\n\t\t\tactor: aexp._id\n        },\n        rollMode: game.settings.get(\"core\", \"rollMode\")\n    };\n\n    // \n    if( costType.includes(\"longterm\") ) {\n        /** Only applicable for Bithir game */\n        chatOptions[\"type\"] = CONST.CHAT_MESSAGE_TYPES.ROLL;\n        chatOptions[\"content\"] = `<h2>Re-roll for daily corruption</h2> \n            ${actorName} paid ${dice.total}  daily corruption for a re-roll`;        \n        chatOptions[\"roll\"] = dice;\n    } else {\n        chatOptions[\"content\"] = `<h2>Re-roll for ${ costType.includes(\"artifactrr\") ? \"experience\":\"permanent corruption\" }</h2>\n            ${actorName} paid 1 ${ costType.includes(\"artifactrr\") ? \"experience\":\"permanent corruption\" } for a re-roll`\n        \n    }\n    ChatMessage.create(chatOptions);     \n    await Actor.updateDocuments(updates);\n    \n    // Post results\n}",
      "flags": {
        "combat-utility-belt": {
          "macroTrigger": ""
        },
        "furnace": {
          "runAsGM": false
        },
        "core": {}
      },
      "ownership": {
        "default": 0,
        "IJbBQp9HIZhYkNtD": 3,
        "yBOfnkxE5pvS5PPZ": 3,
        "p6DS3gYz6OrQ6H9e": 3,
        "YsmQXJ6sqv5HM9Ov": 3
      },
      "_stats": {
        "systemId": "symbaroum",
        "systemVersion": "4.5.0",
        "coreVersion": "13.344",
        "createdTime": 1664298196642,
        "modifiedTime": 1717742554635,
        "lastModifiedBy": "YsmQXJ6sqv5HM9Ov",
        "compendiumSource": "Macro.ZOmWDVLXwLd9aT1L",
        "duplicateSource": null,
        "exportSource": null
      },
      "folder": "Rudp3WGY5YPx13VV",
      "sort": 1000000,
      "_id": "neH7OJagjzF9YEL5"
    },
    {
      "name": "Name Generator",
      "type": "script",
      "author": "YsmQXJ6sqv5HM9Ov",
      "img": "icons/svg/hanging-sign.svg",
      "scope": "global",
      "command": "game.symbaroum.macros.generateNames();",
      "flags": {
        "furnace": {
          "runAsGM": false
        },
        "core": {}
      },
      "ownership": {
        "default": 0,
        "IJbBQp9HIZhYkNtD": 3,
        "yBOfnkxE5pvS5PPZ": 3,
        "p6DS3gYz6OrQ6H9e": 3,
        "YsmQXJ6sqv5HM9Ov": 3
      },
      "_stats": {
        "systemId": "symbaroum",
        "systemVersion": "4.5.0",
        "coreVersion": "13.344",
        "createdTime": 1664296878863,
        "modifiedTime": 1717742554635,
        "lastModifiedBy": "YsmQXJ6sqv5HM9Ov",
        "compendiumSource": "Macro.M2pRCm23Siqt61qp",
        "duplicateSource": null,
        "exportSource": null
      },
      "folder": "Rudp3WGY5YPx13VV",
      "sort": 500000,
      "_id": "1ZgtCdZVSAgOmCRk"
    }
  ],
  "cards": [],
  "playlists": [],
  "folders": [
    {
      "name": "ES - Macros",
      "type": "Macro",
      "folder": null,
      "description": "",
      "sorting": "a",
      "sort": 200000,
      "color": null,
      "flags": {
        "core": {}
      },
      "_stats": {
        "systemId": "symbaroum",
        "systemVersion": "4.5.0",
        "coreVersion": "13.344",
        "createdTime": 1717742554652,
        "modifiedTime": 1717742554652,
        "lastModifiedBy": "YsmQXJ6sqv5HM9Ov",
        "compendiumSource": "Folder.Rudp3WGY5YPx13VV",
        "duplicateSource": null,
        "exportSource": null
      },
      "_id": "Rudp3WGY5YPx13VV"
    }
  ],
  "_id": "Y01wjAZdLjgR098D",
  "flags": {},
  "_stats": {
    "systemId": "symbaroum",
    "systemVersion": "4.0.1",
    "coreVersion": "13.344",
    "createdTime": 1664298357158,
    "modifiedTime": 1717742785853,
    "lastModifiedBy": "YsmQXJ6sqv5HM9Ov",
    "compendiumSource": null,
    "duplicateSource": null,
    "exportSource": null
  },
  "folder": null,
  "_key": "!adventures!Y01wjAZdLjgR098D"
}
